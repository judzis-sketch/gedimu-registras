"use client";

import React, { createContext, useContext, ReactNode, useMemo } from 'react';
import { NewWorkerData, Worker } from '@/lib/types';
import { useCollection, useFirestore, useMemoFirebase } from '@/firebase';
import { collection, doc, addDoc } from 'firebase/firestore';
import { setDocumentNonBlocking, deleteDocumentNonBlocking, addDocumentNonBlocking } from '@/firebase/non-blocking-updates';
import { createUserWithEmailAndPassword } from 'firebase/auth';
import { useAuth } from '@/firebase/provider';


interface WorkersContextType {
  workers: Worker[] | null;
  isLoading: boolean;
  addWorker: (workerData: NewWorkerData) => Promise<void>;
  updateWorker: (workerId: string, workerData: Partial<NewWorkerData>) => void;
  deleteWorker: (workerId: string) => void;
}

const WorkersContext = createContext<WorkersContextType | undefined>(undefined);

export const WorkersProvider = ({ children }: { children: ReactNode }) => {
  const firestore = useFirestore();
  const auth = useAuth();
  const workersCollection = useMemoFirebase(() => collection(firestore, 'employees'), [firestore]);
  const { data: workers, isLoading } = useCollection<Worker>(workersCollection);

  const addWorker = async (workerData: NewWorkerData) => {
    if (!firestore || !workersCollection) return;
    
    // The previous logic attempted to create an auth user and a firestore doc.
    // This is complex and has race conditions. A better pattern is to separate user creation
    // from profile/data creation. Here, we'll just add the worker data to the collection.
    // The admin can create the worker, and the worker can sign up separately.
    const { password, ...workerDocData } = workerData;
    
    try {
      // We no longer create the auth user here. We just add the employee record.
      // The ID will be auto-generated by Firestore.
      await addDocumentNonBlocking(workersCollection, workerDocData);
    } catch (error) {
      console.error("Error creating worker record: ", error);
      throw error; // Re-throw to be handled by the form
    }
  };
  
  const updateWorker = (workerId: string, workerData: Partial<NewWorkerData>) => {
    if (!firestore) return;
    const workerRef = doc(firestore, 'employees', workerId);
    // Password should not be part of the update data for a worker profile
    const { password, ...updateData } = workerData;
    setDocumentNonBlocking(workerRef, updateData, { merge: true });
  };

  const deleteWorker = (workerId: string) => {
    // Note: This only deletes the Firestore document, not the Firebase Auth user.
    // Deleting the auth user requires admin privileges, typically via Firebase Functions.
    if (!firestore) return;
    const workerRef = doc(firestore, 'employees', workerId);
    deleteDocumentNonBlocking(workerRef);
  };

  const contextValue = useMemo(() => ({
    workers,
    isLoading,
    addWorker,
    updateWorker,
    deleteWorker,
  }), [workers, isLoading]);

  return (
    <WorkersContext.Provider value={contextValue}>
      {children}
    </WorkersContext.Provider>
  );
};

export const useWorkers = () => {
  const context = useContext(WorkersContext);
  if (context === undefined) {
    throw new Error('useWorkers must be used within a WorkersProvider');
  }
  return context;
};
